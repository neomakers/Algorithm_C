## (紧凑型)数组
**(紧凑型)数组** 是计算机科学中最简单且最通用的数据结构之一。数组几乎在所有编程语言中都是内置的，例如 C++、Python（在 Python 中，'数组' 被称为 '列表'）、Java 等。
可以使用 **(紧凑型)数组** 来实现列表抽象数据类型（List ADT）。
可以使用 **(紧凑型)数组** 来解决许多经典问题。当数组不用于作为列表抽象数据类型的实现时（其中位置顺序很重要），通常首先对元素进行排序，这样可以使用更快的算法。
紧凑型数组是实现列表抽象数据类型（List ADT）的理想选择，因为它可以简洁地处理一组元素。
所谓紧凑型数组，是指数组中没有空隙。如果数组中有 N 个元素（数组大小为 M，其中 M ≥ N），那么只有索引 [0..N-1] 会被占用，而索引 [N..M-1] 则未被使用。

## 应用
设紧凑型数组名为 A，索引 [0..N-1] 被列表的元素占据。
- **get(i)**：直接返回 A[i]。如果数组不是紧凑型的，这个简单操作将会变得不必要地复杂。
- **search(v)**：我们逐一检查索引 i ∈ [0..N-1]，看 A[i] 是否等于 v。这是因为 v（如果存在的话）可以出现在索引 [0..N-1] 的任何位置。由于在此情况下只接受不重复的元素，v 最多只能被找到一次。在一般的列表抽象数据类型（List ADT）中，我们可能希望 `search(v)` 返回一个索引列表。
- **insert(i, v)**：我们将索引区间 [i..N-1] 的元素向后移动到 [i+1..N]，然后将 A[i] 设置为 v。这确保了 v 被正确插入到索引 i，并保持数组的紧凑性。
- **remove(i)**：我们将索引区间 [i+1..N-1] 的元素向前移动到 [i..N-2]，覆盖原来的 A[i]。这样做是为了保持数组的紧凑性。

## 时间复杂度
- **get(i)** 非常快：只需一次访问，时间复杂度为 O(1)。在另一门课程 "计算机组织" 中，讨论了数组索引操作实现 O(1) 性能的细节。

- **search(v)**：
  - 最佳情况：v 在第一个位置被找到，时间复杂度为 O(1)。
  - 最坏情况：v 不在列表中，我们需要扫描整个列表才能确定，时间复杂度为 O(N)。

- **insert(i, v)**：
  - 最佳情况：在 i = N 处插入，此时无需移动任何元素，时间复杂度为 O(1)。
  - 最坏情况：在 i = 0 处插入，此时需要移动所有 N 个元素，时间复杂度为 O(N)。

- **remove(i)**：
  - 最佳情况：在 i = N-1 处删除，此时无需移动任何元素，时间复杂度为 O(1)。
  - 最坏情况：在 i = 0 处删除，此时需要移动所有 N 个元素，时间复杂度为 O(N)。

## 固定空间大小问题

紧凑型数组的大小 M 不是无限的，而是一个有限的数值。这在很多应用中会带来问题，因为最大大小通常是事先未知的。
- 如果 M 太大，未使用的空间会被浪费。
- 如果 M 太小，空间很容易耗尽。

## 可变大小的空间
解决方案：将 M 设为一个可变的值。当数组已满时，创建一个更大的数组（通常是原来的两倍大小），并将旧数组中的元素移动到新数组中。这样，数组的大小不再受限，唯一的限制来自计算机的物理内存大小（通常非常大）。

C++ STL 的 `std::vector`、Python 的 `list`、Java 的 `Vector` 和 `ArrayList` 都实现了这种可变大小的数组。需要注意的是，Python 的 `list` 和 Java 的 `ArrayList` 并不是链表，而是可变大小的数组。该数组的实现采用了这种满时扩容的策略。

然而，经典的基于数组的问题依然存在，例如空间浪费和复制/移动元素的开销。

## 紧凑型数组的应用
在紧凑型（整数）数组 A 上可以进行多种应用：

- 在数组 A 中搜索特定值 v；
- 在（静态）数组 A 中寻找最小值/最大值或第 k 小/第 k 大的值；
- 测试数组 A 中的元素是否唯一并删除重复项；
- 统计数组 A 中特定值 v 出现的次数；
- 计算数组 A 和另一个已排序数组 B 之间的集合交集/并集；
- 寻找满足 x + y 等于目标值 z 的数组 A 中的两个元素 x 和 y；
- 统计数组 A 中有多少个值落在区间 [lo..hi] 之间，等等。

## 无序数组
我们可以使用 O(N) 的线性搜索（从最左到最右或相反）来查找 v；对于最小值/最大值，我们同样可以使用 O(N) 的线性搜索；对于第 k 小/第 k 大的值，可能需要使用 O(kN) 的算法；我们可以使用 O(N^2) 的嵌套循环来检查数组 A 中是否有两个索引的值相同；可以使用哈希表将这一操作缩减到 O(N)；在某些情况下，需要使用 O(N^2) 的嵌套循环；在某些情况下，也需要 O(N^2) 的嵌套循环；通过哈希表，某些操作可以优化为 O(N)。如果数组是有序的，情况会更好。
注：有更快的算法，比如期望时间 O(N) 的 QuickSelect 或 O(N) 最坏情况的线性选择算法。

## 有序数组

我们可以在有序数组上使用 O(log N) 的二分查找；在（静态有序）数组 A 中，A[0] 是最小值，A[k-1] 是第 k 小的值，A[N-k] 是第 k 大的值，A[N-1] 是最大值；如果有重复元素，它们会在有序数组 A 中相邻排列；与前述相同处理方式；
可以使用归并排序中归并过程的修改版来处理；可以使用双指针方法来解决问题；通过两次二分查找，可以确定索引 y - 索引 x + 1 的范围；当然，还可能有其他方法。

